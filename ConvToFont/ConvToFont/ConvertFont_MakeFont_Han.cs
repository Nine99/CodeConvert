using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using System.Drawing;

namespace ConvToFont
{
	partial class ConvertFont_Main
	{
		static bool GenerateHanBitmapFont(Bitmap _bitmap, MakeFontResult _result )	// int _bit_width, int _bit_height)
		{
			Console.WriteLine("Image Loaded.");
			Console.WriteLine();
			Console.WriteLine("Image Size : {0} x {1}", _bitmap.Width, _bitmap.Height);
			Console.WriteLine("Font Size : {0} x {1}", _result.bitWidth, _result.bitHeight);
			Console.WriteLine();

			_result.hanFontData_Fore = new UInt16[_result.bitHeight * _HAN_FORE_CHAR_NUM * _HAN_FORE_SET_NUM];
			_result.hanFontData_Middle = new UInt16[_result.bitHeight * _HAN_MIDDLE_CHAR_NUM * _HAN_MIDDLE_SET_NUM];
			_result.hanFontData_Under = new UInt16[_result.bitHeight * _HAN_UNDER_CHAR_NUM * _HAN_UNDER_SET_NUM];

			// 초성( 32 byte * 19char * 4 set = 2432 byte )
			for (int set = 0; set < _HAN_FORE_SET_NUM; ++set)
			{
				for (int code = 0; code < _HAN_FORE_CHAR_NUM; ++code)
				{
					for( int wy=0; wy<_result.bitHeight; ++wy )
					{
						int arr_index = ( set * _result.bitHeight  + code ) * _result.bitWidth + wy;
						int py = set * _result.bitHeight + wy;

						for ( int wx=0; wx<_result.bitWidth; ++wx )
						{
							int px = code * _result.bitWidth + wx;

							Color pixel_value = _bitmap.GetPixel(px, py);

							UInt16 bit_value = (UInt16)(pixel_value.R > 0x80 ? 0x8000 : 0x0000);
							_result.hanFontData_Fore[arr_index] |= (UInt16)(bit_value >> wx);
						}
					}
				}
			}

			// 중성( 32 byte * 21 char * 4 set = 2688 byte )
			int middle_offset = _result.bitHeight * 8;      // 초성 8줄 건너뜀

			for (int set = 0; set < _HAN_MIDDLE_SET_NUM; ++set)
			{
				for (int code = 0; code < _HAN_MIDDLE_CHAR_NUM; ++code)
				{
					for (int wy = 0; wy < _result.bitHeight; ++wy)
					{
						int arr_index = (set * _result.bitHeight + code) * _result.bitWidth + wy;
						int py = set * _result.bitHeight + wy + middle_offset;

						for (int wx = 0; wx < _result.bitWidth; ++wx)
						{
							int px = code * _result.bitWidth + wx;

							Color pixel_value = _bitmap.GetPixel(px, py);

							UInt16 bit_value = (UInt16)(pixel_value.R > 0x80 ? 0x8000 : 0x0000);
							_result.hanFontData_Middle[arr_index] |= (UInt16)(bit_value >> wx);
						}
					}
				}
			}

			// 종성( 32 byte * 28 char * 4 set = 3584 byte )
			int under_offset = _result.bitHeight * 12;	// 초성 8줄, 중성 4줄 건너뜀

			for (int set = 0; set < _HAN_UNDER_SET_NUM; ++set)
			{
				for (int code = 0; code < _HAN_UNDER_CHAR_NUM; ++code)
				{
					for (int wy = 0; wy < _result.bitHeight; ++wy)
					{
						int arr_index = (set * _result.bitHeight + code) * _result.bitWidth + wy;
						int py = set * _result.bitHeight + wy + under_offset;

						for (int wx = 0; wx < _result.bitWidth; ++wx)
						{
							int px = code * _result.bitWidth + wx;

							Color pixel_value = _bitmap.GetPixel(px, py);

							UInt16 bit_value = (UInt16)(pixel_value.R > 0x80 ? 0x8000 : 0x0000);
							_result.hanFontData_Under[arr_index] |= (UInt16)(bit_value >> wx);
						}
					}
				}
			}

			return true;
		}

		static string WriteHanBitmapFontToFile(string _arg, MakeFontResult _result)
		{
			string output_file_name = string.Format("{0}\\{1}_{2}x{3}.cpp", Path.GetDirectoryName(_arg), Path.GetFileNameWithoutExtension(_arg), _result.bitWidth, _result.bitHeight);
			string font_name = Path.GetFileNameWithoutExtension(_arg);
			font_name = font_name.Replace("-", "_");
			_result.fontName = string.Format("{0}_{1}x{2}", font_name, _result.bitWidth, _result.bitHeight);

			StreamWriter file = new StreamWriter(output_file_name);

			file.WriteLine("// Font Name : {0}", font_name);
			file.WriteLine("// Generated by Nine99's ConvToFont.exe");
			file.WriteLine();

			WriteHanComponentToCPP(file, _result, _HAN_COMP._FORE);
			WriteHanComponentToCPP(file, _result, _HAN_COMP._MIDDLE);
			WriteHanComponentToCPP(file, _result, _HAN_COMP._UNDER);

			file.WriteLine("uint16_t *	{0}[] = {{", _result.fontName);
			file.WriteLine("\t{0}_Fore,", _result.fontName);
			file.WriteLine("\t{0}_Middle,", _result.fontName); 
			file.WriteLine("\t{0}_Under", _result.fontName);
			file.WriteLine("};");
			file.WriteLine();

			file.Close();

			return output_file_name;
		}

		static bool WriteHanComponentToCPP(StreamWriter _file, MakeFontResult _result, _HAN_COMP _component)
		{
			UInt16[] font_arr = default(UInt16[]);
			int code_len = 0;
			int set_len = 0;

			switch( _component )
			{
				case _HAN_COMP._FORE:
					font_arr = _result.hanFontData_Fore;
					_file.WriteLine("uint16_t {0}_Fore[] = {{", _result.fontName);
					code_len = _HAN_FORE_CHAR_NUM;
					set_len = _HAN_FORE_SET_NUM;
					break;

				case _HAN_COMP._MIDDLE:
					font_arr = _result.hanFontData_Middle;
					_file.WriteLine("uint16_t {0}_Middle[] = {{", _result.fontName);
					code_len = _HAN_MIDDLE_CHAR_NUM;
					set_len = _HAN_MIDDLE_SET_NUM;
					break;

				case _HAN_COMP._UNDER:
					font_arr = _result.hanFontData_Under;
					_file.WriteLine("uint16_t {0}_Under[] = {{", _result.fontName);
					code_len = _HAN_UNDER_CHAR_NUM;
					set_len = _HAN_UNDER_SET_NUM;
					break;

				default:
					return false;
			}

			int last_index = (set_len - 1) * (code_len - 1) * (_result.bitHeight - 1);

			for ( int set_inx = 0; set_inx < set_len; ++set_inx )
			{
				_file.WriteLine("\t// Set {0}", set_inx);
				for (int code_inx = 0; code_inx < code_len; ++code_inx)
				{
					_file.Write("\t");

					for (int line_inx = 0; line_inx < _result.bitHeight; ++line_inx)
					{
						UInt16 data = font_arr[code_inx * _result.bitHeight + line_inx];
						_file.Write("0x{0:X4}", data);

						int arr_index = set_inx * code_inx * line_inx;
						if ( arr_index < last_index )
							_file.Write(", ");
					}
					_file.WriteLine();
				}
			}

			_file.WriteLine("};");
			_file.WriteLine();

			return true;
		}
	}
}
